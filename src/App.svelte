<script>
  // Import classes
  import Station from "./classes/Station.js";
  import TripEntity from "./classes/TripEntity.js";
  import Interval from "./classes/Interval.js";

  // Import hard coded data
  import stationData from "./data/stationData.js";
  import lineGroups from "./data/lineGroups.js";
  import lineGroupIntervals from "./data/lineGroupIntervalsWithShapes.js";
  import shapes from "./data/shapes.js";

  // Import helpers
  import api from "./helpers/api.js";
  import mergeTripUpdateAndVehicleEntities from "./helpers/mergeTripUpdateAndVehicleEntities.js";
  import stationHelpers from "./helpers/stationHelpers.js";
  import leaflet from "./helpers/leaflet.js";

  // Initialize variables
  var tripEntities = []; // Most recent API response
  const trainsArray = []; // Array of Train objects
  let routes = [];
  const stations = {};
  const stationStopIds = [];

  // UPDATE_FREQUENCY_IN_SECONDS is set in /config.js
  const updateFreqency = parseInt(UPDATE_FREQUENCY_IN_SECONDS) * 1000;

  const lineColors = {};
  console.log(lineGroups)
  lineGroups.forEach(i => {
    i.lines.forEach(j => {
      lineColors[j] = i.color
    });
  });

  // const routeData = lineGroups.flatMap(lineGroup => {
  //   return lineGroup.lines.map(line => {
  //     return {
  //       line: line,
  //       color: lineGroup.color,
  //     }
  //   });
  // });

  // // Station data is hard coded
  // // See ./data/stationData.js, which is generated from tools/stationData.csv
  // routes = routeData.map(i => {
  //   return {
  //     stops: stationHelpers.getLineStops(i.line),
  //     color: i.color,
  //   }
  // });

  (async function main() {
    // Draw the map tiles
    leaflet.drawMap();

    // Create a Station object from hard coded station data
    stationData.forEach(i => {
      const station = new Station(i)
      stations[station.stopId] = station;
      stationStopIds.push(station.stopId);
    });

    // Add Interval objects to Station objects from hard coded interval data
    Interval.combineIntervals(lineGroupIntervals, stations);

    // Draw tracks by drawing each interval lines between stations
    stationStopIds.forEach(s => {
      const intervals = stations[s].intervals;
      intervals.forEach(interval => {
        if (true || interval.nStation.stopId === "R32") {
          leaflet.drawInterval(interval);
          // interval.shape.forEach((i, index) => {
          //   if (index > 0) {
          //     leaflet.drawSimpleLine(i, interval.shape[index - 1].slice(0, 2));
          //   }
          // })
        }
      })
      
    })

    // const drawLine = "A";

    // for (let s in shapes[drawLine]) {
    //   const shape = shapes[drawLine][s];
    //   shape.forEach((s1, index) => {
    //     const color = lineColors[drawLine];
    //     if (!shape[index + 1]) return ;
    //     const s2 = shape[index + 1];
    //     const pos1 = {
    //       latitude: s1[0],
    //       longitude: s1[1]
    //     }
    //     const pos2 = {
    //       latitude: s2[0],
    //       longitude: s2[1]
    //     }
    //     leaflet.drawInterval([color], pos1, pos2);
    //   })
    // }

    // Draw dots for each station
    for (let i in stations) {
      leaflet.drawStation(stations[i]);
    }

    // // Parse station data:
    // const stationsAndTracks = parseRoutes(routes); // ðŸš¸ Empty right now
    // // Draw all the stations for each route
    // routes.forEach(i => drawStations(i.stops, i.color));

    // drawLoop();
    // setInterval(drawLoop, updateFreqency);

  })();



  // This function will be run every UPDATE_FREQUENCY_IN_SECONDS seconds
  async function drawLoop() {
    try {
      const lineGroup = lineGroups[0];

      // Get data from API
      tripEntities = await api.getMtaFeed(lineGroup.apiSuffix);
      //console.log(JSON.stringify(tripEntities))
      
      // Combine TripUpdate and Vehicle data:
      const combinedTripEntities = mergeTripUpdateAndVehicleEntities(tripEntities);

      console.log(`${tripEntities.length} entities becomes data for ${combinedTripEntities.length} trains`)
      
      // Validate data and create TripEntity objects
      const tripEntityObjects = combinedTripEntities.map((i, index) => new TripEntity(i, index));
      console.log(`Found ${tripEntityObjects.length} trip entity objects.`)

      // ðŸš¸ Only use "Current" type trips for map
      const currentTrips = tripEntityObjects.filter(i => i.type === "Current");
      const types = {}
      tripEntityObjects.forEach(i => {
        if (types[i.type]) {
          types[i.type] += 1
        } else {
          types[i.type] = 1
        }
      });
      console.log("ðŸ“Š Types\n:", types)
      console.log(`of those ${currentTrips.length} are current`);
      //Draw each train at its updated position on the map
      drawEachTrain(currentTrips);
    } catch (error) {
      console.log("ðŸ–‹Error:", error);
    }
  }

  // Draw each train on map
  function drawEachTrain(currentTrips) {
    console.log("ðŸ§® Received data for", currentTrips.length, "trains", "(", currentTrips.map(i => i.index), ")")
    
    for (var i in currentTrips) {
      let trainUpdate = currentTrips[i];
      try {
        
        let trainObject = trainUpdate.createTrainOrFindTrainIn(trainsArray);

        // ðŸš¸ What are the cases that cause this?
        if (!trainObject) {
          throw "Can't parse train at index " + i;
        }

        trainObject.locate()

        if (!trainObject.marker) {
          // New train is drawn on map:
          trainObject.marker = leaflet.drawTrain(trainObject);
          trainsArray.push(trainObject);

        } else {
          // Existing train is moved if lat or long has changed: 
          if (trainObject.move) {
            trainObject.move = false;
            leaflet.moveTrain(trainObject);
          }
        }
        
      } catch (error) {
        console.log("Error:", error);
      }
    }
  }

  function parseRoutes(routes) {
    const combinedRoutes = routes.flatMap(i => {
      return i.stops.map(j => {
        j.colors = [i.color];
        return j;
      })
    })

    const uniqueStations = {};
    combinedRoutes.forEach(i => {
      const latlng = `${i.latitude}_${i.longitude}`;
      console.log(i)
      if (!uniqueStations[latlng]) {
        uniqueStations[latlng] = i;
      } else {
        uniqueStations[latlng]
      }
    })

  }

  function drawStations(routeStops, color) {
    let prevStation = null;
    for (let i = 0; i < routeStops.length; i++) {

      // Create station object
      const station = routeStops[i];

      // Draw station on map
      leaflet.drawStation(station);

      // Connect new station to previous station:
      if (prevStation) {
        leaflet.drawTracks(prevStation, station, color);
      }

      prevStation = station;
    }
  }

</script>

<style>

</style>